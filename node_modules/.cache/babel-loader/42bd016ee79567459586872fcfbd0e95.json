{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Updater = void 0;\n\nconst Utils_1 = require(\"../../Utils\");\n\nconst Enums_1 = require(\"../../Enums\");\n\nconst OutModeDirection_1 = require(\"../../Enums/Directions/OutModeDirection\");\n\nclass Updater {\n  constructor(container, particle) {\n    this.container = container;\n    this.particle = particle;\n  }\n\n  update(delta) {\n    if (this.particle.destroyed) {\n      return;\n    }\n\n    this.updateLife(delta);\n\n    if (this.particle.destroyed || this.particle.spawning) {\n      return;\n    }\n\n    this.updateOpacity(delta);\n    this.updateSize(delta);\n    this.updateAngle(delta);\n    this.updateColor(delta);\n    this.updateStrokeColor(delta);\n    this.updateOutModes(delta);\n  }\n\n  updateLife(delta) {\n    const particle = this.particle;\n    let justSpawned = false;\n\n    if (particle.spawning) {\n      particle.lifeDelayTime += delta.value;\n\n      if (particle.lifeDelayTime >= particle.lifeDelay) {\n        justSpawned = true;\n        particle.spawning = false;\n        particle.lifeDelayTime = 0;\n        particle.lifeTime = 0;\n      }\n    }\n\n    if (particle.lifeDuration === -1) {\n      return;\n    }\n\n    if (!particle.spawning) {\n      if (justSpawned) {\n        particle.lifeTime = 0;\n      } else {\n        particle.lifeTime += delta.value;\n      }\n\n      if (particle.lifeTime >= particle.lifeDuration) {\n        particle.lifeTime = 0;\n\n        if (particle.livesRemaining > 0) {\n          particle.livesRemaining--;\n        }\n\n        if (particle.livesRemaining === 0) {\n          particle.destroy();\n          return;\n        }\n\n        const canvasSize = this.container.canvas.size;\n        particle.position.x = Utils_1.NumberUtils.randomInRange(0, canvasSize.width);\n        particle.position.y = Utils_1.NumberUtils.randomInRange(0, canvasSize.height);\n        particle.spawning = true;\n        particle.lifeDelayTime = 0;\n        particle.lifeTime = 0;\n        const lifeOptions = particle.particlesOptions.life;\n        particle.lifeDelay = Utils_1.NumberUtils.getValue(lifeOptions.delay) * 1000;\n        particle.lifeDuration = Utils_1.NumberUtils.getValue(lifeOptions.duration) * 1000;\n      }\n    }\n  }\n\n  updateOpacity(delta) {\n    var _a, _b;\n\n    const particle = this.particle;\n\n    if (particle.particlesOptions.opacity.animation.enable) {\n      switch (particle.opacity.status) {\n        case Enums_1.AnimationStatus.increasing:\n          if (particle.opacity.value >= particle.particlesOptions.opacity.value) {\n            particle.opacity.status = Enums_1.AnimationStatus.decreasing;\n          } else {\n            particle.opacity.value += ((_a = particle.opacity.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor;\n          }\n\n          break;\n\n        case Enums_1.AnimationStatus.decreasing:\n          if (particle.opacity.value <= particle.particlesOptions.opacity.animation.minimumValue) {\n            particle.opacity.status = Enums_1.AnimationStatus.increasing;\n          } else {\n            particle.opacity.value -= ((_b = particle.opacity.velocity) !== null && _b !== void 0 ? _b : 0) * delta.factor;\n          }\n\n          break;\n      }\n\n      if (particle.opacity.value < 0) {\n        particle.opacity.value = 0;\n      }\n    }\n  }\n\n  updateSize(delta) {\n    var _a, _b;\n\n    const container = this.container;\n    const particle = this.particle;\n    const sizeOpt = particle.particlesOptions.size;\n    const sizeAnim = sizeOpt.animation;\n    const sizeVelocity = ((_a = particle.size.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor;\n    const maxValue = (_b = particle.sizeValue) !== null && _b !== void 0 ? _b : container.retina.sizeValue;\n    const minValue = sizeAnim.minimumValue * container.retina.pixelRatio;\n\n    if (sizeAnim.enable) {\n      switch (particle.size.status) {\n        case Enums_1.AnimationStatus.increasing:\n          if (particle.size.value >= maxValue) {\n            particle.size.status = Enums_1.AnimationStatus.decreasing;\n          } else {\n            particle.size.value += sizeVelocity;\n          }\n\n          break;\n\n        case Enums_1.AnimationStatus.decreasing:\n          if (particle.size.value <= minValue) {\n            particle.size.status = Enums_1.AnimationStatus.increasing;\n          } else {\n            particle.size.value -= sizeVelocity;\n          }\n\n      }\n\n      switch (sizeAnim.destroy) {\n        case Enums_1.DestroyType.max:\n          if (particle.size.value >= maxValue) {\n            particle.destroy();\n          }\n\n          break;\n\n        case Enums_1.DestroyType.min:\n          if (particle.size.value <= minValue) {\n            particle.destroy();\n          }\n\n          break;\n      }\n\n      if (particle.size.value < 0 && !particle.destroyed) {\n        particle.size.value = 0;\n      }\n    }\n  }\n\n  updateAngle(delta) {\n    var _a;\n\n    const particle = this.particle;\n    const rotate = particle.particlesOptions.rotate;\n    const rotateAnimation = rotate.animation;\n    const speed = ((_a = particle.rotate.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor;\n    const max = 2 * Math.PI;\n\n    if (rotate.path) {\n      particle.pathAngle = Math.atan2(particle.velocity.vertical, particle.velocity.horizontal);\n    } else if (rotateAnimation.enable) {\n      switch (particle.rotate.status) {\n        case Enums_1.AnimationStatus.increasing:\n          particle.rotate.value += speed;\n\n          if (particle.rotate.value > max) {\n            particle.rotate.value -= max;\n          }\n\n          break;\n\n        case Enums_1.AnimationStatus.decreasing:\n        default:\n          particle.rotate.value -= speed;\n\n          if (particle.rotate.value < 0) {\n            particle.rotate.value += max;\n          }\n\n          break;\n      }\n    }\n  }\n\n  updateColor(delta) {\n    var _a;\n\n    const particle = this.particle;\n\n    if (particle.color.value === undefined) {\n      return;\n    }\n\n    if (particle.particlesOptions.color.animation.enable) {\n      particle.color.value.h += ((_a = particle.color.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor;\n\n      if (particle.color.value.h > 360) {\n        particle.color.value.h -= 360;\n      }\n    }\n  }\n\n  updateStrokeColor(delta) {\n    var _a, _b;\n\n    const particle = this.particle;\n    const color = particle.stroke.color;\n\n    if (typeof color === \"string\" || color === undefined) {\n      return;\n    }\n\n    if (particle.strokeColor.value === undefined) {\n      return;\n    }\n\n    if (color.animation.enable) {\n      particle.strokeColor.value.h += ((_b = (_a = particle.strokeColor.velocity) !== null && _a !== void 0 ? _a : particle.color.velocity) !== null && _b !== void 0 ? _b : 0) * delta.factor;\n\n      if (particle.strokeColor.value.h > 360) {\n        particle.strokeColor.value.h -= 360;\n      }\n    }\n  }\n\n  updateOutModes(delta) {\n    var _a, _b, _c, _d;\n\n    const outModes = this.particle.particlesOptions.move.outModes;\n    this.updateOutMode(delta, (_a = outModes.bottom) !== null && _a !== void 0 ? _a : outModes.default, OutModeDirection_1.OutModeDirection.bottom);\n    this.updateOutMode(delta, (_b = outModes.left) !== null && _b !== void 0 ? _b : outModes.default, OutModeDirection_1.OutModeDirection.left);\n    this.updateOutMode(delta, (_c = outModes.right) !== null && _c !== void 0 ? _c : outModes.default, OutModeDirection_1.OutModeDirection.right);\n    this.updateOutMode(delta, (_d = outModes.top) !== null && _d !== void 0 ? _d : outModes.default, OutModeDirection_1.OutModeDirection.top);\n  }\n\n  updateOutMode(delta, outMode, direction) {\n    const container = this.container;\n    const particle = this.particle;\n    const gravityOptions = particle.particlesOptions.move.gravity;\n\n    switch (outMode) {\n      case Enums_1.OutMode.bounce:\n      case Enums_1.OutMode.bounceVertical:\n      case Enums_1.OutMode.bounceHorizontal:\n      case \"bounceVertical\":\n      case \"bounceHorizontal\":\n        this.updateBounce(delta, direction, outMode);\n        break;\n\n      case Enums_1.OutMode.destroy:\n        if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.getRadius(), direction)) {\n          container.particles.remove(particle);\n        }\n\n        break;\n\n      case Enums_1.OutMode.out:\n        if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.getRadius(), direction)) {\n          this.fixOutOfCanvasPosition(direction);\n        }\n\n        break;\n\n      case Enums_1.OutMode.none:\n        if (particle.particlesOptions.move.distance) {\n          return;\n        }\n\n        if (!gravityOptions.enable) {\n          if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.getRadius(), direction)) {\n            container.particles.remove(particle);\n          }\n        } else {\n          const position = particle.position;\n\n          if (gravityOptions.acceleration >= 0 && position.y > container.canvas.size.height && direction === OutModeDirection_1.OutModeDirection.bottom || gravityOptions.acceleration < 0 && position.y < 0 && direction === OutModeDirection_1.OutModeDirection.top) {\n            container.particles.remove(particle);\n          }\n        }\n\n        break;\n    }\n  }\n\n  fixOutOfCanvasPosition(direction) {\n    const container = this.container;\n    const particle = this.particle;\n    const wrap = particle.particlesOptions.move.warp;\n    const canvasSize = container.canvas.size;\n    const newPos = {\n      bottom: canvasSize.height + particle.getRadius() - particle.offset.y,\n      left: -particle.getRadius() - particle.offset.x,\n      right: canvasSize.width + particle.getRadius() + particle.offset.x,\n      top: -particle.getRadius() - particle.offset.y\n    };\n    const sizeValue = particle.getRadius();\n    const nextBounds = Utils_1.Utils.calculateBounds(particle.position, sizeValue);\n\n    if (direction === OutModeDirection_1.OutModeDirection.right && nextBounds.left > canvasSize.width - particle.offset.x) {\n      particle.position.x = newPos.left;\n\n      if (!wrap) {\n        particle.position.y = Math.random() * canvasSize.height;\n      }\n    } else if (direction === OutModeDirection_1.OutModeDirection.left && nextBounds.right < -particle.offset.x) {\n      particle.position.x = newPos.right;\n\n      if (!wrap) {\n        particle.position.y = Math.random() * canvasSize.height;\n      }\n    }\n\n    if (direction === OutModeDirection_1.OutModeDirection.bottom && nextBounds.top > canvasSize.height - particle.offset.y) {\n      if (!wrap) {\n        particle.position.x = Math.random() * canvasSize.width;\n      }\n\n      particle.position.y = newPos.top;\n    } else if (direction === OutModeDirection_1.OutModeDirection.top && nextBounds.bottom < -particle.offset.y) {\n      if (!wrap) {\n        particle.position.x = Math.random() * canvasSize.width;\n      }\n\n      particle.position.y = newPos.bottom;\n    }\n  }\n\n  updateBounce(delta, direction, outMode) {\n    const container = this.container;\n    const particle = this.particle;\n    let handled = false;\n\n    for (const [, plugin] of container.plugins) {\n      if (plugin.particleBounce !== undefined) {\n        handled = plugin.particleBounce(particle, delta, direction);\n      }\n\n      if (handled) {\n        break;\n      }\n    }\n\n    if (handled) {\n      return;\n    }\n\n    const pos = particle.getPosition(),\n          offset = particle.offset,\n          size = particle.getRadius(),\n          bounds = Utils_1.Utils.calculateBounds(pos, size),\n          canvasSize = container.canvas.size;\n\n    if (outMode === Enums_1.OutMode.bounce || outMode === Enums_1.OutMode.bounceHorizontal || outMode === \"bounceHorizontal\") {\n      const velocity = particle.velocity.horizontal;\n      let bounced = false;\n\n      if (direction === OutModeDirection_1.OutModeDirection.right && bounds.right >= canvasSize.width && velocity > 0 || direction === OutModeDirection_1.OutModeDirection.left && bounds.left <= 0 && velocity < 0) {\n        const newVelocity = Utils_1.NumberUtils.getValue(particle.particlesOptions.bounce.horizontal);\n        particle.velocity.horizontal *= -newVelocity;\n        bounced = true;\n      }\n\n      if (bounced) {\n        const minPos = offset.x + size;\n\n        if (bounds.right >= canvasSize.width) {\n          particle.position.x = canvasSize.width - minPos;\n        } else if (bounds.left <= 0) {\n          particle.position.x = minPos;\n        }\n      }\n    }\n\n    if (outMode === Enums_1.OutMode.bounce || outMode === Enums_1.OutMode.bounceVertical || outMode === \"bounceVertical\") {\n      const velocity = particle.velocity.vertical;\n      let bounced = false;\n\n      if (direction === OutModeDirection_1.OutModeDirection.bottom && bounds.bottom >= container.canvas.size.height && velocity > 0 || direction === OutModeDirection_1.OutModeDirection.top && bounds.top <= 0 && velocity < 0) {\n        const newVelocity = Utils_1.NumberUtils.getValue(particle.particlesOptions.bounce.vertical);\n        particle.velocity.vertical *= -newVelocity;\n        bounced = true;\n      }\n\n      if (bounced) {\n        const minPos = offset.y + size;\n\n        if (bounds.bottom >= canvasSize.height) {\n          particle.position.y = canvasSize.height - minPos;\n        } else if (bounds.top <= 0) {\n          particle.position.y = minPos;\n        }\n      }\n    }\n  }\n\n}\n\nexports.Updater = Updater;","map":{"version":3,"sources":["/Users/thoarrow/coder/delete/My-Portforlio-v2/node_modules/tsparticles/dist/Core/Particle/Updater.js"],"names":["Object","defineProperty","exports","value","Updater","Utils_1","require","Enums_1","OutModeDirection_1","constructor","container","particle","update","delta","destroyed","updateLife","spawning","updateOpacity","updateSize","updateAngle","updateColor","updateStrokeColor","updateOutModes","justSpawned","lifeDelayTime","lifeDelay","lifeTime","lifeDuration","livesRemaining","destroy","canvasSize","canvas","size","position","x","NumberUtils","randomInRange","width","y","height","lifeOptions","particlesOptions","life","getValue","delay","duration","_a","_b","opacity","animation","enable","status","AnimationStatus","increasing","decreasing","velocity","factor","minimumValue","sizeOpt","sizeAnim","sizeVelocity","maxValue","sizeValue","retina","minValue","pixelRatio","DestroyType","max","min","rotate","rotateAnimation","speed","Math","PI","path","pathAngle","atan2","vertical","horizontal","color","undefined","h","stroke","strokeColor","_c","_d","outModes","move","updateOutMode","bottom","default","OutModeDirection","left","right","top","outMode","direction","gravityOptions","gravity","OutMode","bounce","bounceVertical","bounceHorizontal","updateBounce","Utils","isPointInside","getRadius","particles","remove","out","fixOutOfCanvasPosition","none","distance","acceleration","wrap","warp","newPos","offset","nextBounds","calculateBounds","random","handled","plugin","plugins","particleBounce","pos","getPosition","bounds","bounced","newVelocity","minPos"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Updater = void 0;\nconst Utils_1 = require(\"../../Utils\");\nconst Enums_1 = require(\"../../Enums\");\nconst OutModeDirection_1 = require(\"../../Enums/Directions/OutModeDirection\");\nclass Updater {\n    constructor(container, particle) {\n        this.container = container;\n        this.particle = particle;\n    }\n    update(delta) {\n        if (this.particle.destroyed) {\n            return;\n        }\n        this.updateLife(delta);\n        if (this.particle.destroyed || this.particle.spawning) {\n            return;\n        }\n        this.updateOpacity(delta);\n        this.updateSize(delta);\n        this.updateAngle(delta);\n        this.updateColor(delta);\n        this.updateStrokeColor(delta);\n        this.updateOutModes(delta);\n    }\n    updateLife(delta) {\n        const particle = this.particle;\n        let justSpawned = false;\n        if (particle.spawning) {\n            particle.lifeDelayTime += delta.value;\n            if (particle.lifeDelayTime >= particle.lifeDelay) {\n                justSpawned = true;\n                particle.spawning = false;\n                particle.lifeDelayTime = 0;\n                particle.lifeTime = 0;\n            }\n        }\n        if (particle.lifeDuration === -1) {\n            return;\n        }\n        if (!particle.spawning) {\n            if (justSpawned) {\n                particle.lifeTime = 0;\n            }\n            else {\n                particle.lifeTime += delta.value;\n            }\n            if (particle.lifeTime >= particle.lifeDuration) {\n                particle.lifeTime = 0;\n                if (particle.livesRemaining > 0) {\n                    particle.livesRemaining--;\n                }\n                if (particle.livesRemaining === 0) {\n                    particle.destroy();\n                    return;\n                }\n                const canvasSize = this.container.canvas.size;\n                particle.position.x = Utils_1.NumberUtils.randomInRange(0, canvasSize.width);\n                particle.position.y = Utils_1.NumberUtils.randomInRange(0, canvasSize.height);\n                particle.spawning = true;\n                particle.lifeDelayTime = 0;\n                particle.lifeTime = 0;\n                const lifeOptions = particle.particlesOptions.life;\n                particle.lifeDelay = Utils_1.NumberUtils.getValue(lifeOptions.delay) * 1000;\n                particle.lifeDuration = Utils_1.NumberUtils.getValue(lifeOptions.duration) * 1000;\n            }\n        }\n    }\n    updateOpacity(delta) {\n        var _a, _b;\n        const particle = this.particle;\n        if (particle.particlesOptions.opacity.animation.enable) {\n            switch (particle.opacity.status) {\n                case Enums_1.AnimationStatus.increasing:\n                    if (particle.opacity.value >= particle.particlesOptions.opacity.value) {\n                        particle.opacity.status = Enums_1.AnimationStatus.decreasing;\n                    }\n                    else {\n                        particle.opacity.value += ((_a = particle.opacity.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor;\n                    }\n                    break;\n                case Enums_1.AnimationStatus.decreasing:\n                    if (particle.opacity.value <= particle.particlesOptions.opacity.animation.minimumValue) {\n                        particle.opacity.status = Enums_1.AnimationStatus.increasing;\n                    }\n                    else {\n                        particle.opacity.value -= ((_b = particle.opacity.velocity) !== null && _b !== void 0 ? _b : 0) * delta.factor;\n                    }\n                    break;\n            }\n            if (particle.opacity.value < 0) {\n                particle.opacity.value = 0;\n            }\n        }\n    }\n    updateSize(delta) {\n        var _a, _b;\n        const container = this.container;\n        const particle = this.particle;\n        const sizeOpt = particle.particlesOptions.size;\n        const sizeAnim = sizeOpt.animation;\n        const sizeVelocity = ((_a = particle.size.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor;\n        const maxValue = (_b = particle.sizeValue) !== null && _b !== void 0 ? _b : container.retina.sizeValue;\n        const minValue = sizeAnim.minimumValue * container.retina.pixelRatio;\n        if (sizeAnim.enable) {\n            switch (particle.size.status) {\n                case Enums_1.AnimationStatus.increasing:\n                    if (particle.size.value >= maxValue) {\n                        particle.size.status = Enums_1.AnimationStatus.decreasing;\n                    }\n                    else {\n                        particle.size.value += sizeVelocity;\n                    }\n                    break;\n                case Enums_1.AnimationStatus.decreasing:\n                    if (particle.size.value <= minValue) {\n                        particle.size.status = Enums_1.AnimationStatus.increasing;\n                    }\n                    else {\n                        particle.size.value -= sizeVelocity;\n                    }\n            }\n            switch (sizeAnim.destroy) {\n                case Enums_1.DestroyType.max:\n                    if (particle.size.value >= maxValue) {\n                        particle.destroy();\n                    }\n                    break;\n                case Enums_1.DestroyType.min:\n                    if (particle.size.value <= minValue) {\n                        particle.destroy();\n                    }\n                    break;\n            }\n            if (particle.size.value < 0 && !particle.destroyed) {\n                particle.size.value = 0;\n            }\n        }\n    }\n    updateAngle(delta) {\n        var _a;\n        const particle = this.particle;\n        const rotate = particle.particlesOptions.rotate;\n        const rotateAnimation = rotate.animation;\n        const speed = ((_a = particle.rotate.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor;\n        const max = 2 * Math.PI;\n        if (rotate.path) {\n            particle.pathAngle = Math.atan2(particle.velocity.vertical, particle.velocity.horizontal);\n        }\n        else if (rotateAnimation.enable) {\n            switch (particle.rotate.status) {\n                case Enums_1.AnimationStatus.increasing:\n                    particle.rotate.value += speed;\n                    if (particle.rotate.value > max) {\n                        particle.rotate.value -= max;\n                    }\n                    break;\n                case Enums_1.AnimationStatus.decreasing:\n                default:\n                    particle.rotate.value -= speed;\n                    if (particle.rotate.value < 0) {\n                        particle.rotate.value += max;\n                    }\n                    break;\n            }\n        }\n    }\n    updateColor(delta) {\n        var _a;\n        const particle = this.particle;\n        if (particle.color.value === undefined) {\n            return;\n        }\n        if (particle.particlesOptions.color.animation.enable) {\n            particle.color.value.h += ((_a = particle.color.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor;\n            if (particle.color.value.h > 360) {\n                particle.color.value.h -= 360;\n            }\n        }\n    }\n    updateStrokeColor(delta) {\n        var _a, _b;\n        const particle = this.particle;\n        const color = particle.stroke.color;\n        if (typeof color === \"string\" || color === undefined) {\n            return;\n        }\n        if (particle.strokeColor.value === undefined) {\n            return;\n        }\n        if (color.animation.enable) {\n            particle.strokeColor.value.h +=\n                ((_b = (_a = particle.strokeColor.velocity) !== null && _a !== void 0 ? _a : particle.color.velocity) !== null && _b !== void 0 ? _b : 0) * delta.factor;\n            if (particle.strokeColor.value.h > 360) {\n                particle.strokeColor.value.h -= 360;\n            }\n        }\n    }\n    updateOutModes(delta) {\n        var _a, _b, _c, _d;\n        const outModes = this.particle.particlesOptions.move.outModes;\n        this.updateOutMode(delta, (_a = outModes.bottom) !== null && _a !== void 0 ? _a : outModes.default, OutModeDirection_1.OutModeDirection.bottom);\n        this.updateOutMode(delta, (_b = outModes.left) !== null && _b !== void 0 ? _b : outModes.default, OutModeDirection_1.OutModeDirection.left);\n        this.updateOutMode(delta, (_c = outModes.right) !== null && _c !== void 0 ? _c : outModes.default, OutModeDirection_1.OutModeDirection.right);\n        this.updateOutMode(delta, (_d = outModes.top) !== null && _d !== void 0 ? _d : outModes.default, OutModeDirection_1.OutModeDirection.top);\n    }\n    updateOutMode(delta, outMode, direction) {\n        const container = this.container;\n        const particle = this.particle;\n        const gravityOptions = particle.particlesOptions.move.gravity;\n        switch (outMode) {\n            case Enums_1.OutMode.bounce:\n            case Enums_1.OutMode.bounceVertical:\n            case Enums_1.OutMode.bounceHorizontal:\n            case \"bounceVertical\":\n            case \"bounceHorizontal\":\n                this.updateBounce(delta, direction, outMode);\n                break;\n            case Enums_1.OutMode.destroy:\n                if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.getRadius(), direction)) {\n                    container.particles.remove(particle);\n                }\n                break;\n            case Enums_1.OutMode.out:\n                if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.getRadius(), direction)) {\n                    this.fixOutOfCanvasPosition(direction);\n                }\n                break;\n            case Enums_1.OutMode.none:\n                if (particle.particlesOptions.move.distance) {\n                    return;\n                }\n                if (!gravityOptions.enable) {\n                    if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.getRadius(), direction)) {\n                        container.particles.remove(particle);\n                    }\n                }\n                else {\n                    const position = particle.position;\n                    if ((gravityOptions.acceleration >= 0 &&\n                        position.y > container.canvas.size.height &&\n                        direction === OutModeDirection_1.OutModeDirection.bottom) ||\n                        (gravityOptions.acceleration < 0 && position.y < 0 && direction === OutModeDirection_1.OutModeDirection.top)) {\n                        container.particles.remove(particle);\n                    }\n                }\n                break;\n        }\n    }\n    fixOutOfCanvasPosition(direction) {\n        const container = this.container;\n        const particle = this.particle;\n        const wrap = particle.particlesOptions.move.warp;\n        const canvasSize = container.canvas.size;\n        const newPos = {\n            bottom: canvasSize.height + particle.getRadius() - particle.offset.y,\n            left: -particle.getRadius() - particle.offset.x,\n            right: canvasSize.width + particle.getRadius() + particle.offset.x,\n            top: -particle.getRadius() - particle.offset.y,\n        };\n        const sizeValue = particle.getRadius();\n        const nextBounds = Utils_1.Utils.calculateBounds(particle.position, sizeValue);\n        if (direction === OutModeDirection_1.OutModeDirection.right && nextBounds.left > canvasSize.width - particle.offset.x) {\n            particle.position.x = newPos.left;\n            if (!wrap) {\n                particle.position.y = Math.random() * canvasSize.height;\n            }\n        }\n        else if (direction === OutModeDirection_1.OutModeDirection.left && nextBounds.right < -particle.offset.x) {\n            particle.position.x = newPos.right;\n            if (!wrap) {\n                particle.position.y = Math.random() * canvasSize.height;\n            }\n        }\n        if (direction === OutModeDirection_1.OutModeDirection.bottom && nextBounds.top > canvasSize.height - particle.offset.y) {\n            if (!wrap) {\n                particle.position.x = Math.random() * canvasSize.width;\n            }\n            particle.position.y = newPos.top;\n        }\n        else if (direction === OutModeDirection_1.OutModeDirection.top && nextBounds.bottom < -particle.offset.y) {\n            if (!wrap) {\n                particle.position.x = Math.random() * canvasSize.width;\n            }\n            particle.position.y = newPos.bottom;\n        }\n    }\n    updateBounce(delta, direction, outMode) {\n        const container = this.container;\n        const particle = this.particle;\n        let handled = false;\n        for (const [, plugin] of container.plugins) {\n            if (plugin.particleBounce !== undefined) {\n                handled = plugin.particleBounce(particle, delta, direction);\n            }\n            if (handled) {\n                break;\n            }\n        }\n        if (handled) {\n            return;\n        }\n        const pos = particle.getPosition(), offset = particle.offset, size = particle.getRadius(), bounds = Utils_1.Utils.calculateBounds(pos, size), canvasSize = container.canvas.size;\n        if (outMode === Enums_1.OutMode.bounce || outMode === Enums_1.OutMode.bounceHorizontal || outMode === \"bounceHorizontal\") {\n            const velocity = particle.velocity.horizontal;\n            let bounced = false;\n            if ((direction === OutModeDirection_1.OutModeDirection.right && bounds.right >= canvasSize.width && velocity > 0) ||\n                (direction === OutModeDirection_1.OutModeDirection.left && bounds.left <= 0 && velocity < 0)) {\n                const newVelocity = Utils_1.NumberUtils.getValue(particle.particlesOptions.bounce.horizontal);\n                particle.velocity.horizontal *= -newVelocity;\n                bounced = true;\n            }\n            if (bounced) {\n                const minPos = offset.x + size;\n                if (bounds.right >= canvasSize.width) {\n                    particle.position.x = canvasSize.width - minPos;\n                }\n                else if (bounds.left <= 0) {\n                    particle.position.x = minPos;\n                }\n            }\n        }\n        if (outMode === Enums_1.OutMode.bounce || outMode === Enums_1.OutMode.bounceVertical || outMode === \"bounceVertical\") {\n            const velocity = particle.velocity.vertical;\n            let bounced = false;\n            if ((direction === OutModeDirection_1.OutModeDirection.bottom &&\n                bounds.bottom >= container.canvas.size.height &&\n                velocity > 0) ||\n                (direction === OutModeDirection_1.OutModeDirection.top && bounds.top <= 0 && velocity < 0)) {\n                const newVelocity = Utils_1.NumberUtils.getValue(particle.particlesOptions.bounce.vertical);\n                particle.velocity.vertical *= -newVelocity;\n                bounced = true;\n            }\n            if (bounced) {\n                const minPos = offset.y + size;\n                if (bounds.bottom >= canvasSize.height) {\n                    particle.position.y = canvasSize.height - minPos;\n                }\n                else if (bounds.top <= 0) {\n                    particle.position.y = minPos;\n                }\n            }\n        }\n    }\n}\nexports.Updater = Updater;\n"]},"metadata":{},"sourceType":"script"}