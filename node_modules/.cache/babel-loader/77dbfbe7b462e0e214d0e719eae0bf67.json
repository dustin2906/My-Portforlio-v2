{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/thoarrow/coder/delete/My-Portforlio-v2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/thoarrow/coder/delete/My-Portforlio-v2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/thoarrow/coder/delete/My-Portforlio-v2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/thoarrow/coder/delete/My-Portforlio-v2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Updater = void 0;\n\nvar Utils_1 = require(\"../../Utils\");\n\nvar Enums_1 = require(\"../../Enums\");\n\nvar OutModeDirection_1 = require(\"../../Enums/Directions/OutModeDirection\");\n\nvar Updater = /*#__PURE__*/function () {\n  function Updater(container, particle) {\n    _classCallCheck(this, Updater);\n\n    this.container = container;\n    this.particle = particle;\n  }\n\n  _createClass(Updater, [{\n    key: \"update\",\n    value: function update(delta) {\n      if (this.particle.destroyed) {\n        return;\n      }\n\n      this.updateLife(delta);\n\n      if (this.particle.destroyed || this.particle.spawning) {\n        return;\n      }\n\n      this.updateOpacity(delta);\n      this.updateSize(delta);\n      this.updateAngle(delta);\n      this.updateColor(delta);\n      this.updateStrokeColor(delta);\n      this.updateOutModes(delta);\n    }\n  }, {\n    key: \"updateLife\",\n    value: function updateLife(delta) {\n      var particle = this.particle;\n      var justSpawned = false;\n\n      if (particle.spawning) {\n        particle.lifeDelayTime += delta.value;\n\n        if (particle.lifeDelayTime >= particle.lifeDelay) {\n          justSpawned = true;\n          particle.spawning = false;\n          particle.lifeDelayTime = 0;\n          particle.lifeTime = 0;\n        }\n      }\n\n      if (particle.lifeDuration === -1) {\n        return;\n      }\n\n      if (!particle.spawning) {\n        if (justSpawned) {\n          particle.lifeTime = 0;\n        } else {\n          particle.lifeTime += delta.value;\n        }\n\n        if (particle.lifeTime >= particle.lifeDuration) {\n          particle.lifeTime = 0;\n\n          if (particle.livesRemaining > 0) {\n            particle.livesRemaining--;\n          }\n\n          if (particle.livesRemaining === 0) {\n            particle.destroy();\n            return;\n          }\n\n          var canvasSize = this.container.canvas.size;\n          particle.position.x = Utils_1.NumberUtils.randomInRange(0, canvasSize.width);\n          particle.position.y = Utils_1.NumberUtils.randomInRange(0, canvasSize.height);\n          particle.spawning = true;\n          particle.lifeDelayTime = 0;\n          particle.lifeTime = 0;\n          var lifeOptions = particle.particlesOptions.life;\n          particle.lifeDelay = Utils_1.NumberUtils.getValue(lifeOptions.delay) * 1000;\n          particle.lifeDuration = Utils_1.NumberUtils.getValue(lifeOptions.duration) * 1000;\n        }\n      }\n    }\n  }, {\n    key: \"updateOpacity\",\n    value: function updateOpacity(delta) {\n      var _a, _b;\n\n      var particle = this.particle;\n\n      if (particle.particlesOptions.opacity.animation.enable) {\n        switch (particle.opacity.status) {\n          case Enums_1.AnimationStatus.increasing:\n            if (particle.opacity.value >= particle.particlesOptions.opacity.value) {\n              particle.opacity.status = Enums_1.AnimationStatus.decreasing;\n            } else {\n              particle.opacity.value += ((_a = particle.opacity.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor;\n            }\n\n            break;\n\n          case Enums_1.AnimationStatus.decreasing:\n            if (particle.opacity.value <= particle.particlesOptions.opacity.animation.minimumValue) {\n              particle.opacity.status = Enums_1.AnimationStatus.increasing;\n            } else {\n              particle.opacity.value -= ((_b = particle.opacity.velocity) !== null && _b !== void 0 ? _b : 0) * delta.factor;\n            }\n\n            break;\n        }\n\n        if (particle.opacity.value < 0) {\n          particle.opacity.value = 0;\n        }\n      }\n    }\n  }, {\n    key: \"updateSize\",\n    value: function updateSize(delta) {\n      var _a, _b;\n\n      var container = this.container;\n      var particle = this.particle;\n      var sizeOpt = particle.particlesOptions.size;\n      var sizeAnim = sizeOpt.animation;\n      var sizeVelocity = ((_a = particle.size.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor;\n      var maxValue = (_b = particle.sizeValue) !== null && _b !== void 0 ? _b : container.retina.sizeValue;\n      var minValue = sizeAnim.minimumValue * container.retina.pixelRatio;\n\n      if (sizeAnim.enable) {\n        switch (particle.size.status) {\n          case Enums_1.AnimationStatus.increasing:\n            if (particle.size.value >= maxValue) {\n              particle.size.status = Enums_1.AnimationStatus.decreasing;\n            } else {\n              particle.size.value += sizeVelocity;\n            }\n\n            break;\n\n          case Enums_1.AnimationStatus.decreasing:\n            if (particle.size.value <= minValue) {\n              particle.size.status = Enums_1.AnimationStatus.increasing;\n            } else {\n              particle.size.value -= sizeVelocity;\n            }\n\n        }\n\n        switch (sizeAnim.destroy) {\n          case Enums_1.DestroyType.max:\n            if (particle.size.value >= maxValue) {\n              particle.destroy();\n            }\n\n            break;\n\n          case Enums_1.DestroyType.min:\n            if (particle.size.value <= minValue) {\n              particle.destroy();\n            }\n\n            break;\n        }\n\n        if (particle.size.value < 0 && !particle.destroyed) {\n          particle.size.value = 0;\n        }\n      }\n    }\n  }, {\n    key: \"updateAngle\",\n    value: function updateAngle(delta) {\n      var _a;\n\n      var particle = this.particle;\n      var rotate = particle.particlesOptions.rotate;\n      var rotateAnimation = rotate.animation;\n      var speed = ((_a = particle.rotate.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor;\n      var max = 2 * Math.PI;\n\n      if (rotate.path) {\n        particle.pathAngle = Math.atan2(particle.velocity.vertical, particle.velocity.horizontal);\n      } else if (rotateAnimation.enable) {\n        switch (particle.rotate.status) {\n          case Enums_1.AnimationStatus.increasing:\n            particle.rotate.value += speed;\n\n            if (particle.rotate.value > max) {\n              particle.rotate.value -= max;\n            }\n\n            break;\n\n          case Enums_1.AnimationStatus.decreasing:\n          default:\n            particle.rotate.value -= speed;\n\n            if (particle.rotate.value < 0) {\n              particle.rotate.value += max;\n            }\n\n            break;\n        }\n      }\n    }\n  }, {\n    key: \"updateColor\",\n    value: function updateColor(delta) {\n      var _a;\n\n      var particle = this.particle;\n\n      if (particle.color.value === undefined) {\n        return;\n      }\n\n      if (particle.particlesOptions.color.animation.enable) {\n        particle.color.value.h += ((_a = particle.color.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor;\n\n        if (particle.color.value.h > 360) {\n          particle.color.value.h -= 360;\n        }\n      }\n    }\n  }, {\n    key: \"updateStrokeColor\",\n    value: function updateStrokeColor(delta) {\n      var _a, _b;\n\n      var particle = this.particle;\n      var color = particle.stroke.color;\n\n      if (typeof color === \"string\" || color === undefined) {\n        return;\n      }\n\n      if (particle.strokeColor.value === undefined) {\n        return;\n      }\n\n      if (color.animation.enable) {\n        particle.strokeColor.value.h += ((_b = (_a = particle.strokeColor.velocity) !== null && _a !== void 0 ? _a : particle.color.velocity) !== null && _b !== void 0 ? _b : 0) * delta.factor;\n\n        if (particle.strokeColor.value.h > 360) {\n          particle.strokeColor.value.h -= 360;\n        }\n      }\n    }\n  }, {\n    key: \"updateOutModes\",\n    value: function updateOutModes(delta) {\n      var _a, _b, _c, _d;\n\n      var outModes = this.particle.particlesOptions.move.outModes;\n      this.updateOutMode(delta, (_a = outModes.bottom) !== null && _a !== void 0 ? _a : outModes.default, OutModeDirection_1.OutModeDirection.bottom);\n      this.updateOutMode(delta, (_b = outModes.left) !== null && _b !== void 0 ? _b : outModes.default, OutModeDirection_1.OutModeDirection.left);\n      this.updateOutMode(delta, (_c = outModes.right) !== null && _c !== void 0 ? _c : outModes.default, OutModeDirection_1.OutModeDirection.right);\n      this.updateOutMode(delta, (_d = outModes.top) !== null && _d !== void 0 ? _d : outModes.default, OutModeDirection_1.OutModeDirection.top);\n    }\n  }, {\n    key: \"updateOutMode\",\n    value: function updateOutMode(delta, outMode, direction) {\n      var container = this.container;\n      var particle = this.particle;\n      var gravityOptions = particle.particlesOptions.move.gravity;\n\n      switch (outMode) {\n        case Enums_1.OutMode.bounce:\n        case Enums_1.OutMode.bounceVertical:\n        case Enums_1.OutMode.bounceHorizontal:\n        case \"bounceVertical\":\n        case \"bounceHorizontal\":\n          this.updateBounce(delta, direction, outMode);\n          break;\n\n        case Enums_1.OutMode.destroy:\n          if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.getRadius(), direction)) {\n            container.particles.remove(particle);\n          }\n\n          break;\n\n        case Enums_1.OutMode.out:\n          if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.getRadius(), direction)) {\n            this.fixOutOfCanvasPosition(direction);\n          }\n\n          break;\n\n        case Enums_1.OutMode.none:\n          if (particle.particlesOptions.move.distance) {\n            return;\n          }\n\n          if (!gravityOptions.enable) {\n            if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.getRadius(), direction)) {\n              container.particles.remove(particle);\n            }\n          } else {\n            var position = particle.position;\n\n            if (gravityOptions.acceleration >= 0 && position.y > container.canvas.size.height && direction === OutModeDirection_1.OutModeDirection.bottom || gravityOptions.acceleration < 0 && position.y < 0 && direction === OutModeDirection_1.OutModeDirection.top) {\n              container.particles.remove(particle);\n            }\n          }\n\n          break;\n      }\n    }\n  }, {\n    key: \"fixOutOfCanvasPosition\",\n    value: function fixOutOfCanvasPosition(direction) {\n      var container = this.container;\n      var particle = this.particle;\n      var wrap = particle.particlesOptions.move.warp;\n      var canvasSize = container.canvas.size;\n      var newPos = {\n        bottom: canvasSize.height + particle.getRadius() - particle.offset.y,\n        left: -particle.getRadius() - particle.offset.x,\n        right: canvasSize.width + particle.getRadius() + particle.offset.x,\n        top: -particle.getRadius() - particle.offset.y\n      };\n      var sizeValue = particle.getRadius();\n      var nextBounds = Utils_1.Utils.calculateBounds(particle.position, sizeValue);\n\n      if (direction === OutModeDirection_1.OutModeDirection.right && nextBounds.left > canvasSize.width - particle.offset.x) {\n        particle.position.x = newPos.left;\n\n        if (!wrap) {\n          particle.position.y = Math.random() * canvasSize.height;\n        }\n      } else if (direction === OutModeDirection_1.OutModeDirection.left && nextBounds.right < -particle.offset.x) {\n        particle.position.x = newPos.right;\n\n        if (!wrap) {\n          particle.position.y = Math.random() * canvasSize.height;\n        }\n      }\n\n      if (direction === OutModeDirection_1.OutModeDirection.bottom && nextBounds.top > canvasSize.height - particle.offset.y) {\n        if (!wrap) {\n          particle.position.x = Math.random() * canvasSize.width;\n        }\n\n        particle.position.y = newPos.top;\n      } else if (direction === OutModeDirection_1.OutModeDirection.top && nextBounds.bottom < -particle.offset.y) {\n        if (!wrap) {\n          particle.position.x = Math.random() * canvasSize.width;\n        }\n\n        particle.position.y = newPos.bottom;\n      }\n    }\n  }, {\n    key: \"updateBounce\",\n    value: function updateBounce(delta, direction, outMode) {\n      var container = this.container;\n      var particle = this.particle;\n      var handled = false;\n\n      var _iterator = _createForOfIteratorHelper(container.plugins),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n              plugin = _step$value[1];\n\n          if (plugin.particleBounce !== undefined) {\n            handled = plugin.particleBounce(particle, delta, direction);\n          }\n\n          if (handled) {\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (handled) {\n        return;\n      }\n\n      var pos = particle.getPosition(),\n          offset = particle.offset,\n          size = particle.getRadius(),\n          bounds = Utils_1.Utils.calculateBounds(pos, size),\n          canvasSize = container.canvas.size;\n\n      if (outMode === Enums_1.OutMode.bounce || outMode === Enums_1.OutMode.bounceHorizontal || outMode === \"bounceHorizontal\") {\n        var velocity = particle.velocity.horizontal;\n        var bounced = false;\n\n        if (direction === OutModeDirection_1.OutModeDirection.right && bounds.right >= canvasSize.width && velocity > 0 || direction === OutModeDirection_1.OutModeDirection.left && bounds.left <= 0 && velocity < 0) {\n          var newVelocity = Utils_1.NumberUtils.getValue(particle.particlesOptions.bounce.horizontal);\n          particle.velocity.horizontal *= -newVelocity;\n          bounced = true;\n        }\n\n        if (bounced) {\n          var minPos = offset.x + size;\n\n          if (bounds.right >= canvasSize.width) {\n            particle.position.x = canvasSize.width - minPos;\n          } else if (bounds.left <= 0) {\n            particle.position.x = minPos;\n          }\n        }\n      }\n\n      if (outMode === Enums_1.OutMode.bounce || outMode === Enums_1.OutMode.bounceVertical || outMode === \"bounceVertical\") {\n        var _velocity = particle.velocity.vertical;\n        var _bounced = false;\n\n        if (direction === OutModeDirection_1.OutModeDirection.bottom && bounds.bottom >= container.canvas.size.height && _velocity > 0 || direction === OutModeDirection_1.OutModeDirection.top && bounds.top <= 0 && _velocity < 0) {\n          var _newVelocity = Utils_1.NumberUtils.getValue(particle.particlesOptions.bounce.vertical);\n\n          particle.velocity.vertical *= -_newVelocity;\n          _bounced = true;\n        }\n\n        if (_bounced) {\n          var _minPos = offset.y + size;\n\n          if (bounds.bottom >= canvasSize.height) {\n            particle.position.y = canvasSize.height - _minPos;\n          } else if (bounds.top <= 0) {\n            particle.position.y = _minPos;\n          }\n        }\n      }\n    }\n  }]);\n\n  return Updater;\n}();\n\nexports.Updater = Updater;","map":{"version":3,"sources":["/Users/thoarrow/coder/delete/My-Portforlio-v2/node_modules/tsparticles/dist/Core/Particle/Updater.js"],"names":["Object","defineProperty","exports","value","Updater","Utils_1","require","Enums_1","OutModeDirection_1","container","particle","delta","destroyed","updateLife","spawning","updateOpacity","updateSize","updateAngle","updateColor","updateStrokeColor","updateOutModes","justSpawned","lifeDelayTime","lifeDelay","lifeTime","lifeDuration","livesRemaining","destroy","canvasSize","canvas","size","position","x","NumberUtils","randomInRange","width","y","height","lifeOptions","particlesOptions","life","getValue","delay","duration","_a","_b","opacity","animation","enable","status","AnimationStatus","increasing","decreasing","velocity","factor","minimumValue","sizeOpt","sizeAnim","sizeVelocity","maxValue","sizeValue","retina","minValue","pixelRatio","DestroyType","max","min","rotate","rotateAnimation","speed","Math","PI","path","pathAngle","atan2","vertical","horizontal","color","undefined","h","stroke","strokeColor","_c","_d","outModes","move","updateOutMode","bottom","default","OutModeDirection","left","right","top","outMode","direction","gravityOptions","gravity","OutMode","bounce","bounceVertical","bounceHorizontal","updateBounce","Utils","isPointInside","getRadius","particles","remove","out","fixOutOfCanvasPosition","none","distance","acceleration","wrap","warp","newPos","offset","nextBounds","calculateBounds","random","handled","plugins","plugin","particleBounce","pos","getPosition","bounds","bounced","newVelocity","minPos"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Updater = void 0;\nconst Utils_1 = require(\"../../Utils\");\nconst Enums_1 = require(\"../../Enums\");\nconst OutModeDirection_1 = require(\"../../Enums/Directions/OutModeDirection\");\nclass Updater {\n    constructor(container, particle) {\n        this.container = container;\n        this.particle = particle;\n    }\n    update(delta) {\n        if (this.particle.destroyed) {\n            return;\n        }\n        this.updateLife(delta);\n        if (this.particle.destroyed || this.particle.spawning) {\n            return;\n        }\n        this.updateOpacity(delta);\n        this.updateSize(delta);\n        this.updateAngle(delta);\n        this.updateColor(delta);\n        this.updateStrokeColor(delta);\n        this.updateOutModes(delta);\n    }\n    updateLife(delta) {\n        const particle = this.particle;\n        let justSpawned = false;\n        if (particle.spawning) {\n            particle.lifeDelayTime += delta.value;\n            if (particle.lifeDelayTime >= particle.lifeDelay) {\n                justSpawned = true;\n                particle.spawning = false;\n                particle.lifeDelayTime = 0;\n                particle.lifeTime = 0;\n            }\n        }\n        if (particle.lifeDuration === -1) {\n            return;\n        }\n        if (!particle.spawning) {\n            if (justSpawned) {\n                particle.lifeTime = 0;\n            }\n            else {\n                particle.lifeTime += delta.value;\n            }\n            if (particle.lifeTime >= particle.lifeDuration) {\n                particle.lifeTime = 0;\n                if (particle.livesRemaining > 0) {\n                    particle.livesRemaining--;\n                }\n                if (particle.livesRemaining === 0) {\n                    particle.destroy();\n                    return;\n                }\n                const canvasSize = this.container.canvas.size;\n                particle.position.x = Utils_1.NumberUtils.randomInRange(0, canvasSize.width);\n                particle.position.y = Utils_1.NumberUtils.randomInRange(0, canvasSize.height);\n                particle.spawning = true;\n                particle.lifeDelayTime = 0;\n                particle.lifeTime = 0;\n                const lifeOptions = particle.particlesOptions.life;\n                particle.lifeDelay = Utils_1.NumberUtils.getValue(lifeOptions.delay) * 1000;\n                particle.lifeDuration = Utils_1.NumberUtils.getValue(lifeOptions.duration) * 1000;\n            }\n        }\n    }\n    updateOpacity(delta) {\n        var _a, _b;\n        const particle = this.particle;\n        if (particle.particlesOptions.opacity.animation.enable) {\n            switch (particle.opacity.status) {\n                case Enums_1.AnimationStatus.increasing:\n                    if (particle.opacity.value >= particle.particlesOptions.opacity.value) {\n                        particle.opacity.status = Enums_1.AnimationStatus.decreasing;\n                    }\n                    else {\n                        particle.opacity.value += ((_a = particle.opacity.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor;\n                    }\n                    break;\n                case Enums_1.AnimationStatus.decreasing:\n                    if (particle.opacity.value <= particle.particlesOptions.opacity.animation.minimumValue) {\n                        particle.opacity.status = Enums_1.AnimationStatus.increasing;\n                    }\n                    else {\n                        particle.opacity.value -= ((_b = particle.opacity.velocity) !== null && _b !== void 0 ? _b : 0) * delta.factor;\n                    }\n                    break;\n            }\n            if (particle.opacity.value < 0) {\n                particle.opacity.value = 0;\n            }\n        }\n    }\n    updateSize(delta) {\n        var _a, _b;\n        const container = this.container;\n        const particle = this.particle;\n        const sizeOpt = particle.particlesOptions.size;\n        const sizeAnim = sizeOpt.animation;\n        const sizeVelocity = ((_a = particle.size.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor;\n        const maxValue = (_b = particle.sizeValue) !== null && _b !== void 0 ? _b : container.retina.sizeValue;\n        const minValue = sizeAnim.minimumValue * container.retina.pixelRatio;\n        if (sizeAnim.enable) {\n            switch (particle.size.status) {\n                case Enums_1.AnimationStatus.increasing:\n                    if (particle.size.value >= maxValue) {\n                        particle.size.status = Enums_1.AnimationStatus.decreasing;\n                    }\n                    else {\n                        particle.size.value += sizeVelocity;\n                    }\n                    break;\n                case Enums_1.AnimationStatus.decreasing:\n                    if (particle.size.value <= minValue) {\n                        particle.size.status = Enums_1.AnimationStatus.increasing;\n                    }\n                    else {\n                        particle.size.value -= sizeVelocity;\n                    }\n            }\n            switch (sizeAnim.destroy) {\n                case Enums_1.DestroyType.max:\n                    if (particle.size.value >= maxValue) {\n                        particle.destroy();\n                    }\n                    break;\n                case Enums_1.DestroyType.min:\n                    if (particle.size.value <= minValue) {\n                        particle.destroy();\n                    }\n                    break;\n            }\n            if (particle.size.value < 0 && !particle.destroyed) {\n                particle.size.value = 0;\n            }\n        }\n    }\n    updateAngle(delta) {\n        var _a;\n        const particle = this.particle;\n        const rotate = particle.particlesOptions.rotate;\n        const rotateAnimation = rotate.animation;\n        const speed = ((_a = particle.rotate.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor;\n        const max = 2 * Math.PI;\n        if (rotate.path) {\n            particle.pathAngle = Math.atan2(particle.velocity.vertical, particle.velocity.horizontal);\n        }\n        else if (rotateAnimation.enable) {\n            switch (particle.rotate.status) {\n                case Enums_1.AnimationStatus.increasing:\n                    particle.rotate.value += speed;\n                    if (particle.rotate.value > max) {\n                        particle.rotate.value -= max;\n                    }\n                    break;\n                case Enums_1.AnimationStatus.decreasing:\n                default:\n                    particle.rotate.value -= speed;\n                    if (particle.rotate.value < 0) {\n                        particle.rotate.value += max;\n                    }\n                    break;\n            }\n        }\n    }\n    updateColor(delta) {\n        var _a;\n        const particle = this.particle;\n        if (particle.color.value === undefined) {\n            return;\n        }\n        if (particle.particlesOptions.color.animation.enable) {\n            particle.color.value.h += ((_a = particle.color.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor;\n            if (particle.color.value.h > 360) {\n                particle.color.value.h -= 360;\n            }\n        }\n    }\n    updateStrokeColor(delta) {\n        var _a, _b;\n        const particle = this.particle;\n        const color = particle.stroke.color;\n        if (typeof color === \"string\" || color === undefined) {\n            return;\n        }\n        if (particle.strokeColor.value === undefined) {\n            return;\n        }\n        if (color.animation.enable) {\n            particle.strokeColor.value.h +=\n                ((_b = (_a = particle.strokeColor.velocity) !== null && _a !== void 0 ? _a : particle.color.velocity) !== null && _b !== void 0 ? _b : 0) * delta.factor;\n            if (particle.strokeColor.value.h > 360) {\n                particle.strokeColor.value.h -= 360;\n            }\n        }\n    }\n    updateOutModes(delta) {\n        var _a, _b, _c, _d;\n        const outModes = this.particle.particlesOptions.move.outModes;\n        this.updateOutMode(delta, (_a = outModes.bottom) !== null && _a !== void 0 ? _a : outModes.default, OutModeDirection_1.OutModeDirection.bottom);\n        this.updateOutMode(delta, (_b = outModes.left) !== null && _b !== void 0 ? _b : outModes.default, OutModeDirection_1.OutModeDirection.left);\n        this.updateOutMode(delta, (_c = outModes.right) !== null && _c !== void 0 ? _c : outModes.default, OutModeDirection_1.OutModeDirection.right);\n        this.updateOutMode(delta, (_d = outModes.top) !== null && _d !== void 0 ? _d : outModes.default, OutModeDirection_1.OutModeDirection.top);\n    }\n    updateOutMode(delta, outMode, direction) {\n        const container = this.container;\n        const particle = this.particle;\n        const gravityOptions = particle.particlesOptions.move.gravity;\n        switch (outMode) {\n            case Enums_1.OutMode.bounce:\n            case Enums_1.OutMode.bounceVertical:\n            case Enums_1.OutMode.bounceHorizontal:\n            case \"bounceVertical\":\n            case \"bounceHorizontal\":\n                this.updateBounce(delta, direction, outMode);\n                break;\n            case Enums_1.OutMode.destroy:\n                if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.getRadius(), direction)) {\n                    container.particles.remove(particle);\n                }\n                break;\n            case Enums_1.OutMode.out:\n                if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.getRadius(), direction)) {\n                    this.fixOutOfCanvasPosition(direction);\n                }\n                break;\n            case Enums_1.OutMode.none:\n                if (particle.particlesOptions.move.distance) {\n                    return;\n                }\n                if (!gravityOptions.enable) {\n                    if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.getRadius(), direction)) {\n                        container.particles.remove(particle);\n                    }\n                }\n                else {\n                    const position = particle.position;\n                    if ((gravityOptions.acceleration >= 0 &&\n                        position.y > container.canvas.size.height &&\n                        direction === OutModeDirection_1.OutModeDirection.bottom) ||\n                        (gravityOptions.acceleration < 0 && position.y < 0 && direction === OutModeDirection_1.OutModeDirection.top)) {\n                        container.particles.remove(particle);\n                    }\n                }\n                break;\n        }\n    }\n    fixOutOfCanvasPosition(direction) {\n        const container = this.container;\n        const particle = this.particle;\n        const wrap = particle.particlesOptions.move.warp;\n        const canvasSize = container.canvas.size;\n        const newPos = {\n            bottom: canvasSize.height + particle.getRadius() - particle.offset.y,\n            left: -particle.getRadius() - particle.offset.x,\n            right: canvasSize.width + particle.getRadius() + particle.offset.x,\n            top: -particle.getRadius() - particle.offset.y,\n        };\n        const sizeValue = particle.getRadius();\n        const nextBounds = Utils_1.Utils.calculateBounds(particle.position, sizeValue);\n        if (direction === OutModeDirection_1.OutModeDirection.right && nextBounds.left > canvasSize.width - particle.offset.x) {\n            particle.position.x = newPos.left;\n            if (!wrap) {\n                particle.position.y = Math.random() * canvasSize.height;\n            }\n        }\n        else if (direction === OutModeDirection_1.OutModeDirection.left && nextBounds.right < -particle.offset.x) {\n            particle.position.x = newPos.right;\n            if (!wrap) {\n                particle.position.y = Math.random() * canvasSize.height;\n            }\n        }\n        if (direction === OutModeDirection_1.OutModeDirection.bottom && nextBounds.top > canvasSize.height - particle.offset.y) {\n            if (!wrap) {\n                particle.position.x = Math.random() * canvasSize.width;\n            }\n            particle.position.y = newPos.top;\n        }\n        else if (direction === OutModeDirection_1.OutModeDirection.top && nextBounds.bottom < -particle.offset.y) {\n            if (!wrap) {\n                particle.position.x = Math.random() * canvasSize.width;\n            }\n            particle.position.y = newPos.bottom;\n        }\n    }\n    updateBounce(delta, direction, outMode) {\n        const container = this.container;\n        const particle = this.particle;\n        let handled = false;\n        for (const [, plugin] of container.plugins) {\n            if (plugin.particleBounce !== undefined) {\n                handled = plugin.particleBounce(particle, delta, direction);\n            }\n            if (handled) {\n                break;\n            }\n        }\n        if (handled) {\n            return;\n        }\n        const pos = particle.getPosition(), offset = particle.offset, size = particle.getRadius(), bounds = Utils_1.Utils.calculateBounds(pos, size), canvasSize = container.canvas.size;\n        if (outMode === Enums_1.OutMode.bounce || outMode === Enums_1.OutMode.bounceHorizontal || outMode === \"bounceHorizontal\") {\n            const velocity = particle.velocity.horizontal;\n            let bounced = false;\n            if ((direction === OutModeDirection_1.OutModeDirection.right && bounds.right >= canvasSize.width && velocity > 0) ||\n                (direction === OutModeDirection_1.OutModeDirection.left && bounds.left <= 0 && velocity < 0)) {\n                const newVelocity = Utils_1.NumberUtils.getValue(particle.particlesOptions.bounce.horizontal);\n                particle.velocity.horizontal *= -newVelocity;\n                bounced = true;\n            }\n            if (bounced) {\n                const minPos = offset.x + size;\n                if (bounds.right >= canvasSize.width) {\n                    particle.position.x = canvasSize.width - minPos;\n                }\n                else if (bounds.left <= 0) {\n                    particle.position.x = minPos;\n                }\n            }\n        }\n        if (outMode === Enums_1.OutMode.bounce || outMode === Enums_1.OutMode.bounceVertical || outMode === \"bounceVertical\") {\n            const velocity = particle.velocity.vertical;\n            let bounced = false;\n            if ((direction === OutModeDirection_1.OutModeDirection.bottom &&\n                bounds.bottom >= container.canvas.size.height &&\n                velocity > 0) ||\n                (direction === OutModeDirection_1.OutModeDirection.top && bounds.top <= 0 && velocity < 0)) {\n                const newVelocity = Utils_1.NumberUtils.getValue(particle.particlesOptions.bounce.vertical);\n                particle.velocity.vertical *= -newVelocity;\n                bounced = true;\n            }\n            if (bounced) {\n                const minPos = offset.y + size;\n                if (bounds.bottom >= canvasSize.height) {\n                    particle.position.y = canvasSize.height - minPos;\n                }\n                else if (bounds.top <= 0) {\n                    particle.position.y = minPos;\n                }\n            }\n        }\n    }\n}\nexports.Updater = Updater;\n"]},"metadata":{},"sourceType":"script"}